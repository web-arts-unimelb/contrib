<?php
/**
 * @file
 * Split CSS groups into separate template variables.
 */

/**
 * Implements hook_element_info().
 */
function css_splitter_element_info() {
  $types = array();

  $css_groups = css_splitter_groups();
  foreach ($css_groups as $name => $group) {
    $types['styles_' . $name] = array(
      '#items' => array(),
      '#pre_render' => array('drupal_pre_render_styles'),
      '#group_callback' => 'drupal_group_css',
      '#aggregate_callback' => 'drupal_aggregate_css',
    );
  }

  return $types;
}

/**
 * Implements hook_css_splitter_groups_info().
 */
function css_splitter_css_splitter_groups_info() {
  // Return the system CSS groups defined in common.inc.
  return array(
    'system' => CSS_SYSTEM,
    'default' => CSS_DEFAULT,
    'theme' => CSS_THEME
  );
}

/**
 * Implements hook_css_splitter_groups_alter().
 */
function css_splitter_css_splitter_groups_alter(&$css_groups) {
  // Doing nothing, just here to show it exists.
}

/**
 * Get defined CSS groups.
 *
 * @return
 *   A keyed array of CSS groups.
 */
function css_splitter_groups() {
  $css_groups = &drupal_static(__FUNCTION__, array());

  if (empty($css_groups)) {
    // Get all groups.
    $css_groups = module_invoke_all('css_splitter_groups_info');

    // Call alter hooks, so contrib modules can change the group info.
    drupal_alter('css_splitter_groups', $css_groups);
  }

  return $css_groups;
}

/**
 * Implements hook_preprocess_html().
 */
function css_splitter_preprocess_html(&$variables) {
  $css_groups = css_splitter_groups();

  // Call drupal_render() to force any CSS that was added via page_build() and
  // that now sits in an #attached element somewhere to be added to the global
  // static css array. Operate on a copy $page['page_bottom'], so the original
  // info is still present when template_process_html() uses it.
  $page_bottom = $variables['page']['page_bottom'];
  drupal_render($page_bottom);

  // Make a template variable for each CSS group.
  foreach ($css_groups as $name => $group) {
    $variables['styles_' . $name] = _css_splitter_get_css($name, $group);
  }
}

/**
 * Return CSS for a given style group.
 *
 * Slight modification to drupal_get_css().
 *
 * @param $name
 *   A string that contains the CSS group name.
 * @param $group
 *   An integer that identifies the group and its weighting.
 *
 * @return
 *   A string of XHTML CSS tags.
 */
function _css_splitter_get_css($name, $group) {
  $css = drupal_add_css();
  drupal_alter('css', $css);

  // Sort CSS items, so that they appear in the correct order.
  uasort($css, 'drupal_sort_css_js');

  if (!empty($css)) {
    // Cast the array to an object to be on the safe side even if not empty.
    $setting['ajaxPageState']['css'] = (object) array_fill_keys(array_keys($css), 1);
  }

  // Do not process if not in the correct group.
  foreach ($css as $key => $item) {
    if ($item['group'] != $group) {
      unset($css[$key]);
      continue;
    }
  }

  // Remove the overridden CSS files. Later CSS files override former ones.
  $previous_item = array();
  foreach ($css as $key => $item) {
    if ($item['type'] == 'file') {
      // If defined, force a unique basename for this file.
      $basename = isset($item['basename']) ? $item['basename'] : drupal_basename($item['data']);
      if (isset($previous_item[$basename])) {
        // Remove the previous item that shared the same base name.
        unset($css[$previous_item[$basename]]);
      }
      $previous_item[$basename] = $key;
    }
  }

  // Render the HTML needed to load the CSS.
  $styles = array(
    '#type' => 'styles',
    '#items' => $css,
  );

  if (!empty($setting)) {
    $styles['#attached']['js'][] = array(
      'type' => 'setting',
      'data' => $setting,
    );
  }

  dpm($name);
  dpm($styles);

  return drupal_render($styles);
}
